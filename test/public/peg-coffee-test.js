// Generated by CoffeeScript 1.3.3
(function() {
  var CoffeeScript, PEG, PEGCoffee, expect;

  if (typeof require !== 'undefined') {
    CoffeeScript = require('coffee-script');
    expect = require('expect.js');
    PEG = require('pegjs');
    PEGCoffee = require('../lib/peg-coffee');
  } else {
    CoffeeScript = global.CoffeeScript;
    expect = global.expect;
    PEG = global.PEG;
    PEGCoffee = global.PEGCoffee;
  }

  suite('peg-coffee', function() {
    setup(function() {
      return PEGCoffee.initialize(PEG);
    });
    suite('initialize plugin', function() {
      test('adds pass to passes', function() {
        var passes;
        passes = PEG.compiler.passes;
        return expect(passes).to.have.property('compileFromCoffeeScript');
      });
      test('adds pass to appliedPassNames', function() {
        var appliedPassNames, expectedPassNames;
        appliedPassNames = PEG.compiler.appliedPassNames;
        expectedPassNames = ['reportMissingRules', 'reportLeftRecursion', 'removeProxyRules', 'compileFromCoffeeScript', 'computeVarNames', 'computeParams'];
        return expect(appliedPassNames).to.eql(expectedPassNames);
      });
      test('pass should only be added once', function() {
        PEGCoffee.initialize(PEG);
        PEGCoffee.initialize(PEG);
        return expect(PEG.compiler.appliedPassNames.length).to.equal(6);
      });
      return test('removes itself when remove() is called', function() {
        var appliedPassNames, expectedPassNames;
        PEGCoffee.remove(PEG);
        appliedPassNames = PEG.compiler.appliedPassNames;
        expectedPassNames = ['reportMissingRules', 'reportLeftRecursion', 'removeProxyRules', 'computeVarNames', 'computeParams'];
        expect(appliedPassNames).to.eql(expectedPassNames);
        return expect(PEG.compiler.passes).to.not.have.property('compileFromCoffeeScript');
      });
    });
    return suite('compile grammar', function() {
      return suite('simple CoffeeScript', function() {
        test('action', function() {
          var parser;
          parser = PEG.buildParser('start = "a" { return "#{1+1}" }');
          return expect(parser.parse("a")).to.equal("2");
        });
        test('initializer', function() {
          var parser;
          parser = PEG.buildParser('{\n  global.val = "#{1+1}"\n}\nstart\n  = "a" { return @val }');
          return expect(parser.parse("a")).to.equal("2");
        });
        suite('predicates', function() {
          test('semantic not code', function() {
            var parser;
            parser = PEG.buildParser('start\n  = !{return typeof Array is "undefined"}');
            return expect(parser.parse("")).to.equal("");
          });
          return test('semantic and code', function() {
            var parser;
            parser = PEG.buildParser('start\n  = &{return typeof Array isnt "undefined"}');
            return expect(parser.parse("")).to.equal("");
          });
        });
        return suite('variable use', function() {
          test('can use label variables', function() {
            var parser;
            parser = PEG.buildParser('start\n  = a:"a" &{return a is "a"}');
            return expect(parser.parse("a")).to.eql(["a", ""]);
          });
          test('can use the |offset| variable to get the current parse position', function() {
            var parser;
            parser = PEG.buildParser('start\n  = "a" &{return offset is 1}');
            return expect(parser.parse("a")).to.eql(["a", ""]);
          });
          return test('can use the |line| and |column| variables to get the current line and column', function() {
            var parser;
            parser = PEG.buildParser('{\n  global.result = "test"\n}\nstart = line (nl+ line)* {return @result }\nline  = thing (" "+ thing)*\nthing = digit / mark\ndigit = [0-9]\nmark  = &{ @result = [line, column]; return true } "x"\nnl    = ("\\r" / "\\n" / "\\u2028" / "\\u2029")', {
              trackLineAndColumn: true
            });
            return expect(parser.parse("1\n2\n\n3\n\n\n4 5 x")).to.eql([7, 5]);
          });
        });
      });
    });
  });

}).call(this);
