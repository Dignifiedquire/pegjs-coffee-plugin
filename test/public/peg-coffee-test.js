// Generated by CoffeeScript 1.3.3
(function() {
  var CoffeeScript, PEG, PEGCoffee, expect;

  if (typeof require !== 'undefined') {
    CoffeeScript = require('coffee-script');
    expect = require('expect.js');
    PEG = require('pegjs');
    PEGCoffee = require('../lib/peg-coffee');
  } else {
    CoffeeScript = global.CoffeeScript;
    expect = global.expect;
    PEG = global.PEG;
    PEGCoffee = global.PEGCoffee;
  }

  suite('peg-coffee', function() {
    setup(function() {
      return PEGCoffee.initialize(PEG);
    });
    suite('initialize plugin', function() {
      test('adds pass to passes', function() {
        var passes;
        passes = PEG.compiler.passes;
        return expect(passes).to.have.property('compileFromCoffeeScript');
      });
      test('adds pass to appliedPassNames', function() {
        var appliedPassNames, expectedPassNames;
        appliedPassNames = PEG.compiler.appliedPassNames;
        expectedPassNames = ['reportMissingRules', 'reportLeftRecursion', 'removeProxyRules', 'compileFromCoffeeScript', 'computeVarNames', 'computeParams'];
        return expect(appliedPassNames).to.eql(expectedPassNames);
      });
      return test('pass should only be added once', function() {
        PEGCoffee.initialize(PEG);
        PEGCoffee.initialize(PEG);
        return expect(PEG.compiler.appliedPassNames.length).to.equal(6);
      });
    });
    return suite('compile grammar', function() {
      return suite('simple CoffeeScript', function() {
        test('action', function() {
          var parser;
          parser = PEG.buildParser('start = "a" { return "#{1+1}" }');
          return expect(parser.parse("a")).to.equal("2");
        });
        test('initializer', function() {
          var parser;
          parser = PEG.buildParser('{\n  val = "#{1+1}"\n}\nstart\n  = "a" { return val }');
          return expect(parser.parse("a")).to.equal("2");
        });
        suite('predicates', function() {
          test('semantic not code', function() {
            var parser;
            parser = PEG.buildParser('start\n  = !{return typeof Array is "undefined"}');
            return expect(parser.parse("")).to.equal("");
          });
          return test('semantic and code', function() {
            var parser;
            parser = PEG.buildParser('start\n  = &{return typeof Array isnt "undefined"}');
            return expect(parser.parse("")).to.equal("");
          });
        });
        return suite('variable use', function() {
          test('can use label variables', function() {
            var parser;
            parser = PEG.buildParser('start\n  = a:"a" &{return a is "a"}');
            return expect(parser.parse("a")).to.eql(["a", ""]);
          });
          return test('can use the |offset| variable to get the current parse position', function() {
            var parser;
            parser = PEG.buildParser('start\n  = "a" &{return offset is 1}');
            return expect(parser.parse("a")).to.eql(["a", ""]);
          });
        });
      });
    });
  });

}).call(this);
